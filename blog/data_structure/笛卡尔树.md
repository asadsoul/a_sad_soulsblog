## 笛卡尔树

笛卡尔树是一种二叉树，每个节点都由一个二元组 $(k,w)$ 所构成，要求 $k$ 满足二叉搜索树的性质，而 $w$ 满足堆的性质。一个有趣的事实是，如果笛卡尔树的 $k,w$ 已经确定，并且 $k$ 不相同，$w$ 不相同， **那么这个笛卡尔树结构唯一**。


### 笛卡尔树的构建

#### 栈构建

我们将元素按照键值 $k$ 排序，然后一个个插入笛卡尔树中。那么每次我们插入的元素必然在这个树的右链末端。于是我们可以这样操作：

1.从下往上比较右链节点的键值，若有 $x_w<u_w$，则将 $u$ 接到 $x$ 右儿子

2.将 $x$ 原本右子树变为 $u$ 的左子树。

显然每个数最多进出右链一次（或者说每个点在右链中存在的是连续的一段时间）。那么显然的，我们可以用栈维护，栈中维护当前笛卡尔树的右链节点，非右链节点弹出改栈。可以发现，时间复杂度是 $O(n)$ 的。

下面是一段示例代码

```cpp
for(int i=1;i<=n;++i){
    int k=top;
    while(k&&h[st[k]]>h[i])--k;
    if(k)rs(st[k])=i;
    if(k<top)ls(i)=st[k+1];
    st[++k]=i;
    top=k;
}

```

