<!--å‰è¨€ï¼šæˆ‘ç›´æ¥æ‹¿æˆ‘GitHubçš„ä»“åº“åšå›¾åºŠæ‰€ä»¥å›¾ç‰‡åŠ è½½å¯èƒ½æœ‰äº›æ…¢ç”šè‡³åŠ è½½ä¸å‡ºæ¥ï¼Œè¯·å¥½å¥½åæ€è‡ªå·±ç½‘ç»œæœ‰æ²¡æœ‰åœ¨åŠªåŠ›å·¥ä½œï¼ˆbushiï¼‰-->

## T1

å¾ˆç®€å•çš„çš„é“ç»ƒæ‰‹é¢˜ï¼Œç›´æ¥ç¦»æ•£åŒ–æšä¸¾å³å¯

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 200005;
int n;
long long m;
int sum[MAXN<<4];
vector<long long >q;
unordered_map<long long ,int >pos;
long long h[MAXN];


int main(){
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%lld",&h[i]),q.push_back(h[i]);
	long long ans=0;
	for(int i=1;i<=n;++i){
		q.push_back(i-h[i]);
		q.push_back(i+h[i]);
	}
	sort(q.begin(),q.end());
	int sz=unique(q.begin(),q.end())-q.begin()+1;
	for(int i=0;i<sz;++i)pos[q[i]]=i+1;
	for(int i=1;i<=n;++i){
		int pa=pos[i-h[i]],pb=pos[i+h[i]];	
		ans+=sum[pa]+sum[pb];
		sum[pa]++,sum[pb]++;
	}
	printf("%lld\n",ans);
	return 0;
	
}

```


## T2

é¢˜ç›®éœ€è¦æŒ‰ä½æˆ–ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªåŒºé—´çš„æ¯ä¸€ä¸ªæ•°ä¸­çš„0å’Œ1åªèƒ½æ˜¯å…¶å­é›†ã€‚é‚£ä¹ˆæˆ‘ä»¬åˆå§‹åŒ–æ•´ä¸ªæ•°ç»„ä¸º $2^{30}-1$ ,è¡¨ç¤ºåˆå§‹æ¯ä¸€ä½æ•°éƒ½æ˜¯1ï¼Œç„¶åå¯¹æ¯ä¸ªåŒºé—´éƒ½åšä¸€æ¬¡æŒ‰ä½ä¸ï¼Œæœ€åæ£€æŸ¥ä¸€ä¸‹æ˜¯å¦ç¬¦åˆè¦æ±‚å³å¯ã€‚è¿‡ç¨‹æˆ‘æ˜¯ç”¨çº¿æ®µæ ‘å®ç°çš„ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n\log n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 100005;
struct node{
	int l,r;
	//bool p; æ‹·ä»£ç çš„æ—¶å€™æ‹·é”™äº†ï¼Œè¿™é‡ŒåŸæœ¬æ˜¯é€ ä»…æœ‰0å’Œ1çš„æ•°æ®ç”¨çš„ï¼Œæ°¸è¿œç¼…æ€€
	int p;
}tree[MAXN<<4];
int n,m;
#define ls(x)(x<<1)
#define rs(x)(x<<1|1)
void build(int p,int l,int r){
	tree[p].p=(1<<31)-1;
	tree[p].l=l,tree[p].r=r;
	if(l==r)return ;
	int mid=(l+r)>>1;
	build(ls(p),l,mid),build(rs(p),mid+1,r);
}

void pushdown(int p){
	tree[ls(p)].p&=tree[p].p;
	tree[rs(p)].p&=tree[p].p;
}

void Update(int p,int L,int R,int v){
	int l=tree[p].l,r=tree[p].r,mid=(l+r)>>1;
	if(L<=l&&r<=R){
		tree[p].p&=v;
		return ;
	}
	pushdown(p);
	if(L<=mid)Update(ls(p),L,R,v);
	if(mid<R)Update(rs(p),L,R,v);
}
int query(int p,int pos){
	int l=tree[p].l,r=tree[p].r,mid=(l+r)>>1;
	if(l==r){
		return tree[p].p;
	}
	pushdown(p);
	if(pos<=mid)return query(ls(p),pos);
	else return query(rs(p),pos);
}

int ans[MAXN];
struct Node{
	int l,r;
	int v;
}T[MAXN<<4];
void Build(int p,int l,int r){
	T[p].l=l,T[p].r=r;int mid=(l+r)>>1;
	if(l==r){T[p].v=ans[l];return ;}
	Build(ls(p),l,mid),Build(rs(p),mid+1,r);
	T[p].v=T[ls(p)].v|T[rs(p)].v;
}
int Query(int p,int L,int R){
	int re=0,l=T[p].l,r=T[p].r,mid=(l+r)>>1;
	if(L<=l&&r<=R)return T[p].v;
	if(L<=mid)re=re|Query(ls(p),L,R);
	if(mid<R)re=re|Query(rs(p),L,R);
	return re;
}
int a[MAXN],l[MAXN],r[MAXN],x[MAXN];

int main(){
	freopen("b.in","r",stdin);
	freopen("b.out","w",stdout);
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&l[i],&r[i],&x[i]);
		int cnt=0;
		int mid=x[i];
		Update(1,l[i],r[i],x[i]);
	}
	for(int i=1;i<=n;++i)ans[i]=query(1,i);
	Build(1,1,n);
	bool sus=true;
	for(int i=1;i<=m;++i){
		if(Query(1,l[i],r[i])!=x[i])sus=false;
	}
	if(!sus)printf("No\n");
	else{
		printf("Yes\n");
		for(int i=1;i<=n;++i)printf("%d ",ans[i]);
	}
	return 0;
}

```


## T3

### SubTask1

æš´åŠ›æšä¸¾ï¼Œ30åˆ†æ‹¿ä¸‹ï¼

## Solution

çœ‹åˆ° $gcd$ ï¼Œç›´æ¥æƒ³åˆ°æšä¸¾è¿™ä¸ª $gcd$ ã€‚

ä½†æ˜¯æƒ³äº†æƒ³æ—¶é—´å¤æ‚åº¦æ˜¯ä¸èƒ½æ¥å—çš„ï¼Œå½“æ—¶è€ƒè¯•çš„æ—¶å€™ä¹Ÿæ²¡æƒ³å¥½æ€ä¹ˆå¤„ç†ï¼Œç„¶ååé¢çš„åˆ†å°±æ”¾å¼ƒäº†ã€‚

çœ‹äº†ä¸‹é¢˜è§£å‘ç°æœ‰è¿™å¥è¯:


![](https://pic.imge.cc/2024/07/29/66a7403c5f195.png)


![1448f0b39ec4cc511c465aeb7f9c1efc.png](https://krseoul.imgtbl.com/i/2024/07/29/66a7415855efd.png)


è‹¥è‡³ç«Ÿæ˜¯æˆ‘è‡ªå·±ï¼Œæ¥ä¸‹æ¥çš„è¿‡ç¨‹å°±å¾ˆç®€å•äº†ï¼Œæšä¸¾æ¯ä¸ªå› å­ç„¶åè®¡ç®—å³å¯ã€‚

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e6+10 ;
struct node{
    int to,pre;
    int next;
}e[MAXN<<1];
int tot,n,head[MAXN];
void add(int u,int v){
    e[++tot].to=v;
    e[tot].pre=u;
    e[tot].next=head[u];
    head[u]=tot;
}
int ans[MAXN];
bool vis[MAXN];
int mxl;
int Get_dis(int u,int fa){
    vis[u]=true;
    int mx0=0,mx1=0;
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==fa)continue;
        int d=Get_dis(v,u);
        if(d>=mx0)mx1=mx0,mx0=d;
        else if(d>mx1)mx1=d;
    }
    mxl=max(mxl,mx1+mx0);
    return mx0+1;
}
int mx;
vector<pair<int,int>>to[MAXN];
int main(){
    scanf("%d",&n);
    for(int i=1;i<n;++i){
        pair<int,int>arr;
       int w;scanf("%d%d%d",&arr.first,&arr.second,&w);
       to[w].push_back(arr);
       mx=max(mx,w); 
    }
    for(int i=1;i<=mx;++i){
        for(int j=i;j<=mx;j+=i){
                for(pair<int,int>arr : to[j]){
                    add(arr.first,arr.second),add(arr.second,arr.first);
            }
        }
        mxl=0;
        for(int j=tot;j;j--)if(!vis[e[j].pre])Get_dis(e[j].pre,0);
        ans[mxl]=i;
        for(int j=1;j<=tot;++j)vis[e[j].pre]=0,head[e[j].pre]=0;
        tot=0;
    }
    for(int i=n;i;--i)ans[i]=max(ans[i+1],ans[i]);
    for(int i=1;i<=n;++i)printf("%d\n",ans[i]);
    return 0;
}

```


## T4

### SubTask1

å¯¹æ¯æ¬¡è¯¢é—®ï¼Œå°†æ¯æ¡è¾¹å¤§äºç­‰äºkçš„è¾¹åˆå¹¶èµ·æ¥ï¼Œç”¨å¹¶æŸ¥é›†ç»´æŠ¤ï¼Œå¯ä»¥é¢„å…ˆå°†é›†åˆå¤„ç†å®Œæ¯•ï¼Œç„¶åèƒ½æ‹¿åˆ°å‰30%çš„åˆ†æ•°ã€‚

è€ƒè¯•çš„æ—¶å€™è„‘å­æŠ½äº†ç›´æ¥æ¨¡æ‹Ÿè·‘æœ€çŸ­è·¯æœ‰30åˆ†æ²¡æ‹¿åˆ°ã€‚

### SbuTask2

è§‚å¯Ÿåˆ°æœ‰30%çš„ç‚¹ä¸ç”¨å¼ºåˆ¶åœ¨çº¿ï¼Œé‚£ä¹ˆå¯ä»¥è½¬ç¦»çº¿åšæ³•ï¼Œè¿™é‡Œæˆ‘æœ‰30ptã€‚

å°†ä¸€ä¸ªæ•°æ”¾åˆ°èƒ½æ•´é™¤å…¶çš„é›†åˆä¸­ï¼Œä»å¤§å¾€å°æ‰«æå¹¶åˆå¹¶ç­”æ¡ˆã€‚

åˆ°ç°åœ¨ï¼Œä¸€å…±æœ‰60åˆ†æ˜¯å¯ä»¥ä¸éœ€è¦æƒ³å‡ºæ­£è§£å°±èƒ½æ‹¿åˆ°åˆ†çš„ï¼Œä½†æ˜¯æˆ‘æ²¡æ‹¿åˆ°æˆ‘æ˜¯ğŸ¤¡


### Solution

ç›´æ¥è´´æ­£è§£å§æˆ‘ä¹Ÿä¸ä¼šå†™ï¼ŒæŒºéš¾çš„è¿™é¢˜QAQ

![673152fc14bd7599690f47c9d96679e7.png](https://vip.helloimg.com/i/2024/07/29/66a752251eca6.png)

![49e3e91131f86f818eff5daf2a63efc5.png](https://vip.helloimg.com/i/2024/07/29/66a75224ef6b5.png)

